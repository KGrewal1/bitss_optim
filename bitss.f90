MODULE BITSSMODULE
  IMPLICIT NONE
  CONTAINS


  FUNCTION DISTANCE(COORDS1, COORDS2, GRAD)
    DOUBLE PRECISION, INTENT(IN) :: COORDS1(NOPT), COORDS2(NOPT)
    DOUBLE PRECISION, INTENT(OUT) :: DISTANCE
    DOUBLE PRECISION, INTENT(OUT), OPTIONAL :: GRAD(NOPT)
    DOUBLE PRECISION :: DIFF
    DIFF = COORDS1 - COORDS2
    DISTANCE = NORM2(DIFF)
    IF (PRESENT(GRAD)) GRAD = DIFF / DISTANCE
  END FUNCTION DISTANCE


  FUNCTION BARRIER_ESTIMATE(COORDS1, COORDS2)
    DOUBLE PRECISION, INTENT(IN) :: COORDS1(NOPT), COORDS2(NOPT)
    DOUBLE PRECISION, INTENT(OUT) :: BARRIER_ESTIMATE
    INTEGER :: I
    DOUBLE PRECISION :: EMIN, EMAX, T, COORDST

    EMIN = MAX(POT(COORDS1), POT(COORDS2))
    EMAX = - HUGE(EMAX)
    DO I = 1, 9
      T = I / 10
      COORDSXT = (1-T)*COORDS1 + T*COORDS2
      EMAX = MAX(EMAX, POT(COORDST))
    END DO
    BARRIER_ESTIMATE = EMAX - EMIN
  END FUNCTION BARRIER_ESTIMATE


  SUBROUTINE COMPUTE_COEF(COORDS1, COORDS2, GRAD1, GRAD2, KE, KD)
    DOUBLE PRECISION, INTENT(IN) :: COORDS1(NOPT), COORDS2(NOPT), GRAD1(NOPT), GRAD2(NOPT)
    DOUBLE PRECISION, INTENT(OUT) :: KE, KD
    USE KEY, ONLY : BITSSALPHA, BITSSBETA
    DOUBLE PRECISION :: EB, D, KD1, KD2

    EB = BARRIER_ESTIMATE(COORDS1, COORDS2)
    D = DISTANCE(COORDS1, COORDS2)

    KE = BITSSALPHA / (2 * EB)
    KD1 = SQRT(SUM(G1**2) + SUM(G2**2)) / (2.8284 * BITSSBETA * D)
    KD2 = EB / (BITSSBETA * D**2)
    KD = MAX(KD1, KD2)
  END SUBROUTINE COMPUTE_COEF


  FUNCTION CHECK_CONVERGENCE(COORDS1, COORDS2)
    DOUBLE PRECISION, INTENT(IN) :: COORDS1(NOPT), COORDS2(NOPT)
    DOUBLE PRECISION, INTENT(OUT) :: CHECK_CONVERGENCE
  END FUNCTION CHECK_CONVERGENCE


  SUBROUTINE BITSS_EG(COORDS, TARGET_DIST, ENERGY, GRAD)
    DOUBLE PRECISION, INTENT(IN) :: COORDS(2*NOPT), GRAD(2*NOPT),, TARGET_DIST
    DOUBLE PRECISION, INTENT(OUT) :: ENERGY
    DOUBLE PRECISION :: E1, E2, G1, G2, D, GD, RMS
    DOUBLE PRECISION :: COORDS1(NOPT), COORDS2(NOPT)
    ASSOCIATE(COORDS1=>COORDS(1:NOPT), COORDS2=>COORDS(NOPT+1:2*NOPT), GRAD1=>GRAD(1:NOPT), GRAD2=>GRAD(NOPT+1:2*NOPT))

    CALL POTENTIAL(COORDS1, E1, G1, .TRUE., .FALSE., RMS, .FALSE., .FALSE.)
    CALL POTENTIAL(COORDS2, E2, G2, .TRUE., .FALSE., RMS, .FALSE., .FALSE.)
    D = DISTANCE(COORDS1, COORDS2, GD)
    ENERGY = E1 + E2 + KE*(E1-E2)**2 + KD*(D - TARGET_DIST)**2
    GRAD1 = (1 + 2*KE*(E1-E2))*G1 + 2*KD*(D - TARGET_DIST)*GD
    GRAD2 = (1 + 2*KE*(E2-E1))*G2 - 2*KD*(D - TARGET_DIST)*GD
  END SUBROUTINE BITSS_EG


  SUBROUTINE MINIMISE(COORDS1, COORDS2, TARGET_DIST)
    DOUBLE PRECISION, INTENT(INOUT) :: COORDS1(NOPT), COORDS2(NOPT)
    DOUBLE PRECISION, INTENT(IN) :: TARGET_DIST
    INTEGER :: ITER, MAXITER
    DOUBLE PRECISION :: COORDS(2*NOPT), E, G1, G2

    COORDS(1:NOPT) = COORDS1
    COORDS(NOPT+1:2*NOPT) = COORDS2

    MAXITER = 10000
    DO ITER = 1, MAXITER
      CALL BITSS_EG(COORDS, TARGET_DIST, E, G1, G2)
      IF (MINIMIZE_CHECK_CONVERGENCE(COORDS1, COORDS2)) EXIT
      CALL MINIMIZE_STEP(COORDS1, COORDS2, GRAD1, GRAD2)
    END DO

    COORDS1 = COORDS(1:NOPT)
    COORDS2 = COORDS(NOPT+1:2*NOPT)
  END SUBROUTINE BITSS


  SUBROUTINE BITSS(COORDS1, COORDS2)
    DOUBLE PRECISION, INTENT(INOUT) :: COORDS1(NOPT), COORDS2(NOPT)
    USE KEY, ONLY : BITSSSTOP, BITSSMAXITER
    INTEGER :: ITER
    DOUBLE PRECISION :: TARGET_DIST

    TARGET_DIST = DISTANCE(COORDS1, COORDS2)

    DO ITER = 1, BITSSMAXITER
      TARGET_DIST = (1 - BITSSSTEP) * TARGET_DIST
      CALL MINIMIZE(COORDS1, COORDS2, TARGET_DIST)

      IF (CHECK_CONVERGENCE(COORDS1, COORDS2) .OR. TARGET_DIST<BITSSSTOP) EXIT
    END DO
  END SUBROUTINE BITSS


END MODULE BITSSMODULE
